#!/bin/bash

## helpers ####################################################################

# Save the name of this script, so it can refer to itself correctly even if the
# user renamed it to something else when they installed it.
export prog=$(basename "${BASH_SOURCE[0]}")

with_err()    { >&2 "$@" ; }
abort()       { [ $# -gt 0 ] && with_err echo ${BASH_SOURCE[0]}: "$@"; exit 1; }
assert()      { local msg=$1; shift; if ! "$@" >/dev/null 2>&1; then abort "$msg"; fi; }
assert_var()  { assert "$1 environment variable must be set" [ -n "${!1}" ]; }

with_rst()    { "$@"; echo -ne "\033[0m"; }
with_col()    { echo -ne "\033[${1}m"; shift; "$@"; }

with_bold()   { with_col 1 with_rst "$@"; }
with_ul()     { with_col 4 with_rst "$@"; }
with_yellow() { with_col 33 with_rst "$@"; }

b()           { with_bold echo -n "$@"; }
i()           { with_ul echo -n "$@"; }

info()        { with_bold echo "$@"; }
warn()        { with_bold with_yellow echo "$@"; }

export -f with_err abort assert assert_var

## assertions #################################################################

for i in aws gpg; do
  assert "required tool '$i' not found on PATH" which $i
done

## global and environment variables ###########################################

export ZERKENV_DIR=${ZERKENV_DIR:-$HOME/.zerkenv} # The local cache directory.

# Fetching of modules from S3 is done in batches in subshells, so it is not
# convenient to try to pass failures back via exit status, and subshells can't
# send information to the parent process via environment variables, so we re-
# cord individual failures in this file, created by the parent process. Child
# processes get the filename from the environment variable they inherit from
# the parent and record individual S3 read failures in it. This prevents the
# user from seeing multiple failed attempts to read modules from S3.
if [ -z "$ZERKENV_FAILS" ]; then
  mkdir -p "$ZERKENV_DIR"
  assert "can't create local cache directory: $ZERKENV_DIR" [ -d "$ZERKENV_DIR" ]
  export ZERKENV_FAILS="$ZERKENV_DIR/$$.tmp"
  touch "$ZERKENV_FAILS"
  trap "rm -f '$ZERKENV_FAILS'" EXIT
fi

## command line option flags ##################################################

opt_completions=false
opt_resolve_deps=false
opt_update_cache=false
opt_delete_cache=false
opt_delete_s3=false

## module operations ##########################################################

ls_s3() {
  assert_var ZERKENV_BUCKET
  aws s3api list-objects --bucket $ZERKENV_BUCKET --output text \
    |awk -F\\t '$1 == "CONTENTS" {print $3}' \
    |grep '\.sh$' \
    |sed 's@\.sh$@@' \
    |sort
}

ls_cache() {
  find "$ZERKENV_DIR" -type f -name '*.sh.asc' \
    |sed "s@^$ZERKENV_DIR/@@" \
    |sed 's@\.sh\.asc$@@'
}

ls_loaded()   { echo "$ZERKENV_MODULES" |grep . |sort -u ; }
cache_file()  { echo "$ZERKENV_DIR/$1.sh.asc" ; }
s3_file()     { assert_var ZERKENV_BUCKET ; echo "s3://$ZERKENV_BUCKET/$1.sh" ; }
encrypt()     { gpg --batch -q -a -e --default-recipient $USER ; }
decrypt()     { gpg --batch -q -d ; }
not_private() { if ! [ ${1:0:1} = @ ]; then true; else false; fi ; }
is_cached()   { [ -f "$(cache_file $1)" ] ; }

put_cache() {
  local file="$(cache_file $1)"
  local src=$(cat)
  if [ -n "$src" ]; then
    mkdir -p "$(dirname "$file")"
    echo "$src" |encrypt > $file
  fi
}

get_cache() {
  local file="$(cache_file $1)"
  [ -f "$file" ] && cat "$file" |decrypt
}

get_s3() {
  local src
  assert_var ZERKENV_BUCKET
  if not_private $1; then
    src=$(aws s3 cp "$(s3_file $1)" -)
    if [ -n "$src" ]; then
      echo "$src" |put_cache $1
    else
      echo $1 >> "$ZERKENV_FAILS"
    fi
  fi
}

put_s3() {
  local file src
  assert_var ZERKENV_BUCKET
  if not_private $1; then
    src="$(get_cache $1)"
    if [ -n "$src" ]; then
      echo "$src" |aws s3 cp - "$(s3_file $1)" > /dev/null
    else
      with_err warn "* $1 not found"
    fi
  else
    with_err warn "* $1 is private so cannot be uploaded to S3"
    abort
  fi
}

get_cache_or_s3() {
  local i ff=$ZERKENV_FAILS
  local failed=$(sort <(echo $1) <(cat "$ff" |sort -u) |uniq -d)
  is_cached $1 || [ -n "$failed" ] || get_s3 $1
  get_cache $1
}

update_cache() {
  local module found modules="$@" local_modules=$(ls_cache) remote_modules
  assert_var ZERKENV_BUCKET
  remote_modules=$(ls_s3)
  if [ $# -eq 0 ]; then
    modules=$(sort <(echo "$remote_modules") <(echo "$local_modules") |uniq -d)
  fi
  for module in $modules; do
    found=$(sort <(echo "$module") <(echo "$remote_modules") |uniq -d)
    if ! not_private $module; then
      with_err warn "* $module is private so cannot be updated from S3"
    elif [ -n "$found" ]; then
      with_err info "* $module"
      get_s3 $module
    else
      with_err warn "* $module not found"
    fi
  done
}

rm_cache() {
  local module file
  for module in "$@"; do
    file=$(cache_file $module)
    if [ -f "$file" ]; then
      with_err info "* $module"
      rm -f "$file"
    else
      with_err warn "* $module not found"
    fi
  done
}

rm_s3() {
  local module file
  assert_var ZERKENV_BUCKET
  for module in "$@"; do
    file=$(s3_file $module)
    if aws s3 rm "$file"; then
      with_err info "* $module"
    else
      with_err warn "* $module not deleted"
    fi
  done
}

resolve_dependencies_impl() {
  local deps module ZERKENV_DEPENDENCIES

  for module in "$@"; do
    . <(get_cache_or_s3 $module)
    for dep in $module $ZERKENV_DEPENDENCIES; do
      deps="$deps $dep $module"
    done
    ZERKENV_DEPENDENCIES=
  done

  echo "$deps" |tsort
}

resolve_dependencies() {
  local i deps prev=$(for i in "$@"; do echo $i; done)

  export ZERKENV_RESOLVING_DEPENDENCIES=true
  while true; do
    deps=$(resolve_dependencies_impl $prev)
    [ "$deps" = "$prev" ] && break
    prev=$deps
  done
  unset ZERKENV_RESOLVING_DEPENDENCIES

  echo "$deps"
}

## completion #################################################################

completions() {
  if [ $# -lt 3 ]; then
    echo "-d -h -i -l -r -u -w -W -x -X $($0 -l)"
  elif [ $# -lt 4 ]; then
    case $2 in
      -i) basename $SHELL ;;
      -u) $0 -l |grep -v '^@' ;;
      -h|-l|-r) ;;
      *) $0 -l ;;
    esac
  else
    case $2 in
      -h|-i|-l|-r|-w|-W) ;;
      -u) $0 -l |grep -v '^@' ;;
      *) $0 -l ;;
    esac
  fi
  exit
}

## configuration hooks ########################################################

install_bash() {
  cat <<'EOT' |envsubst '$prog'
zerkload() {
  local OPTIND OPTARG o newshell=false
  while getopts "hn" o; do
    case "${o}" in
      h) echo "USAGE: zerkload [-hn] <module>..." ; return ;;
      n) newshell=true ;;
      ?) return 1 ;;
    esac
  done
  shift $((OPTIND-1))
  [ $# -eq 0 ] && return
  if $newshell; then
    eval "( zerkload $* ; exec $BASH )"
  else
    . <($prog -d "$@")
  fi
}
_zerkenv() {
  local cur=${COMP_WORDS[COMP_CWORD]}
  local ses=$($prog -c "${COMP_WORDS[@]}")
  COMPREPLY=( $(compgen -W "$ses" -- $cur) )
}
_zerkload() {
  COMPREPLY=( $(compgen -W "-h -n $($prog -l)" -- ${COMP_WORDS[COMP_CWORD]}) )
}
complete -F _zerkenv $prog
complete -F _zerkload zerkload
EOT
}

# TODO: implement completions in fish
install_fish() {
  cat <<'EOT'
  function zerkload
    if test (count $argv) -eq 0; or test $argv[1] = '-h'
      echo "USAGE: zerkload [-h] <module> ..."
    else
      bass . (zerkenv -d $argv | psub)
    end
  end
EOT
}

install() {
  case $1 in
    bash) install_bash ;;
    fish) install_fish ;;
    *) abort unsupported shell: $1 ;;
  esac
}

## main #######################################################################

usage() {
  cat <<EOF
$(b NAME)
      zerkenv - manage environment variables

$(b SYNOPSIS)
      $(b $prog) [$(b -hlr)]
      $(b $prog -c) [$(i arg)...]
      $(b $prog -i) $(i shell)
      $(b $prog -w) $(i module)
      $(b $prog -W) $(i module)
      $(b $prog -u) [$(i module)...]
      $(b $prog ) [$(b -dxX)] $(i module) [$(i module)...]

$(b DESCRIPTION)
      Without arguments lists currently loaded modules, one per line. With arg-
      uments lists, uploads,  or fetches environment configuration modules from
      the local repo specified in the $(b ZERKENV_DIR) environment variable (default
      location ~/.zerkenv) or the S3 bucket specified in the $(b ZERKENV_BUCKET) en-
      vironment variable.  Downloaded  modules are cached in the local repo and
      written to stdout, suitable for evaluation in a shell.

      There are two types of modules:
        · $(b Shared)    These modules may be stored in S3.
        · $(b Private)   These modules will only be stored in the local cache.

      Private module names start with the $(b @) character.

$(b OPTIONS)
      $(b -c) $(i arg)...
            Print completion words (used for shell tab-completion).

      $(b -d) $(i module)...
            Print contents of $(i module)s, resolving dependencies.

      $(b -h)    Show this help message and exit.

      $(b -i bash), $(b -i fish)
            Print startup snippet suitable for shell rc file.

      $(b -l)    List modules available in the local cache directory.

      $(b -r)    List modules available in S3.

      $(b -u) [$(i module)...]
            Update $(i module)s (or all) in local cache.

      $(b -w) $(i module)
            Read source from stdin and write to local <module>.

      $(b -W) $(i module)
            Upload $(i module) from the local repo to S3.

      $(b -x) $(i module)...
            Delete $(i module)s from local repo.

      $(b -X) $(i module)...
            Delete $(i module)s from S3.

$(b MODULES)
      Modules are bash snippets.  The special $(b ZERKENV_DEPENDENCIES) variable may
      be used to declare dependencies on other modules (by name).  Modules  are
      loaded in dependency order so modules may refer to variables that are set
      in the modules on which they depend.  Additionally, the special  environ-
      variable $(b ZERKENV_RESOLVING_DEPENDENCIES) will be set during the dependency
      resolution phase, and may be used as a guard to prevent sections from be-
      ing evaluated during this phase.

$(b EXAMPLES)
      # List modules loaded in the current shell environment:
      $prog

      # List modules available in the local cache:
      $prog -l

      # List modules available in S3:
      $prog -r

      # Print the contents of modules foo, bar, and baz, without dependencies:
      $prog foo bar baz

      # Print the contents of modules foo, bar, baz, plus their dependencies:
      $prog -d foo bar baz

      # Load modules foo, bar, and baz into current shell (bash):
      . <($prog -d foo bar baz)

      # Write module to local cache as mod1, depending on modules dep1 and dep2:
      cat <<EOT | $prog -w mod1
      ZERKENV_DEPENDENCIES="dep1 dep2"
      export USERNAME=admin
      export PASSWORD=hunter2
      EOT
EOF
}

while getopts "cdhi:lruw:W:xX" o; do
  case "${o}" in
    c) opt_completions=true ; break ;;
    d) opt_resolve_deps=true ; break ;;
    h) usage |less -r; exit ;;
    i) install $OPTARG; exit $? ;;
    l) ls_cache ; exit $? ;;
    r) ls_s3 ; exit $? ;;
    u) opt_update_cache=true ; break ;;
    w) put_cache $OPTARG ; exit $? ;;
    W) put_s3 $OPTARG ; exit $? ;;
    x) opt_delete_cache=true ; break ;;
    X) opt_delete_s3=true ; break ;;
    ?) exit 1 ;;
  esac
done
shift $((OPTIND-1))

if $opt_completions; then
  completions "$@"
elif $opt_update_cache; then
  update_cache "$@"
elif $opt_delete_cache; then
  assert "module name required" [ $# -gt 0 ]
  rm_cache "$@"
elif $opt_delete_s3; then
  assert "module name required" [ $# -gt 0 ]
  rm_s3 "$@"
elif ! $opt_resolve_deps && [ $# -eq 0 ]; then
  ls_loaded
elif [ $# -gt 0 ]; then
  modules=$(for i in "$@"; do echo $i; done |sort -u)

  if $opt_resolve_deps; then
    modules=$(resolve_dependencies $modules)
  fi

  if [ -n "$modules" ]; then
    for module in $modules; do
      src=$(get_cache_or_s3 $module)
      if [ -n "$src" ]; then
        with_err info "* $module"
        echo "$src"
      else
        failed="$failed $module"
        with_err warn "* $module not found"
      fi
    done
    if $opt_resolve_deps; then
      failed=$(for i in $failed; do echo $i; done)
      deduped=$(sort -u <(echo "$modules") <(echo "$ZERKENV_MODULES"))
      nofails=$(sort <(echo "$deduped") <(echo "$failed") <(echo "$failed") |uniq -u)
      printf 'export ZERKENV_MODULES="%s"\n' "$nofails"
    fi
  fi
fi
